# FAQ - å¸¸è§é—®é¢˜è§£ç­”

æœ¬æ–‡æ¡£æ”¶é›†äº† AssetX ç”¨æˆ·ç»å¸¸æå‡ºçš„é—®é¢˜å’Œè¯¦ç»†è§£ç­”ã€‚

## åŸºç¡€æ¦‚å¿µ

### Q1: AssetX æ˜¯ä»€ä¹ˆï¼Ÿå®ƒèƒ½è§£å†³ä»€ä¹ˆé—®é¢˜ï¼Ÿ

**A:** AssetX æ˜¯ä¸€ä¸ªå¤šæ ¼å¼æœºå™¨äººä»¿çœŸèµ„äº§æ¡¥æ¢å·¥å…·ï¼Œä¸»è¦è§£å†³ä»¥ä¸‹é—®é¢˜ï¼š

1. **æ ¼å¼è½¬æ¢**: åœ¨ URDFã€MJCFã€USDã€Genesis JSON ç­‰æ ¼å¼é—´è‡ªåŠ¨è½¬æ¢
2. **ç‰©ç†éªŒè¯**: æ£€æŸ¥ä¸åŒæ ¼å¼é—´ç‰©ç†å‚æ•°çš„ä¸€è‡´æ€§
3. **ç½‘æ ¼å¤„ç†**: ä¼˜åŒ– 3D æ¨¡å‹ï¼Œå‡å°‘æ–‡ä»¶å¤§å°ï¼Œæé«˜ä»¿çœŸæ€§èƒ½
4. **èµ„äº§ç®¡ç†**: ç»Ÿä¸€çš„å…ƒæ•°æ®ç®¡ç†ï¼Œç‰ˆæœ¬æ§åˆ¶å’Œè¿½è¸ª
5. **å¯è§†åŒ–**: ä¾¿æ·çš„ 3D é¢„è§ˆå’Œæ£€æŸ¥å·¥å…·

### Q2: AssetX æ”¯æŒå“ªäº›æœºå™¨äººä»¿çœŸæ ¼å¼ï¼Ÿ

**A:** ç›®å‰æ”¯æŒçŠ¶æ€ï¼š

| æ ¼å¼ | è¯»å– | å†™å…¥ | è½¬æ¢æ”¯æŒ | çŠ¶æ€ |
|------|------|------|----------|------|
| URDF | âœ… | âœ… | ä½œä¸ºä¸­é—´æ ¼å¼ | å®Œå…¨æ”¯æŒ |
| MJCF | âœ… | âœ… | URDF â†” MJCF | å®Œå…¨æ”¯æŒ |
| USD | ğŸ”„ | ğŸ”„ | è®¡åˆ’ä¸­ | å¼€å‘ä¸­ |
| Genesis JSON | ğŸ”„ | ğŸ”„ | è®¡åˆ’ä¸­ | å¼€å‘ä¸­ |

### Q3: AssetX ä¸å…¶ä»–å·¥å…·çš„åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿ

**A:** AssetX çš„ç‹¬ç‰¹ä¼˜åŠ¿ï¼š

- **ä¸€ç«™å¼è§£å†³æ–¹æ¡ˆ**: é›†æˆè½¬æ¢ã€éªŒè¯ã€ä¼˜åŒ–ã€ç®¡ç†åŠŸèƒ½
- **ç‰©ç†å‚æ•°ä¿çœŸ**: ä¸“æ³¨äºä¿æŒç‰©ç†å‚æ•°åœ¨è½¬æ¢è¿‡ç¨‹ä¸­çš„ä¸€è‡´æ€§
- **æ™ºèƒ½ç½‘æ ¼å¤„ç†**: è‡ªåŠ¨ä¼˜åŒ–ç½‘æ ¼ï¼Œå¹³è¡¡è´¨é‡å’Œæ€§èƒ½
- **å…ƒæ•°æ®ç®¡ç†**: å®Œæ•´çš„ç‰ˆæœ¬è¿½è¸ªå’Œèµ„äº§ç®¡ç†
- **æ•™è‚²å‹å¥½**: æä¾›æ¸è¿›å¼å­¦ä¹ èµ„æºå’Œæ•™å­¦æ”¯æŒ

---

## å®‰è£…ä¸é…ç½®

### Q4: AssetX çš„ç³»ç»Ÿè¦æ±‚æ˜¯ä»€ä¹ˆï¼Ÿ

**A:** æœ€ä½ç³»ç»Ÿè¦æ±‚ï¼š

- **æ“ä½œç³»ç»Ÿ**: Windows 10+, Ubuntu 18.04+, macOS 10.14+
- **Python**: 3.8 æˆ–æ›´é«˜ç‰ˆæœ¬
- **å†…å­˜**: 4GB RAM (æ¨è 8GB+)
- **å­˜å‚¨**: 1GB å¯ç”¨ç©ºé—´
- **æ˜¾å¡**: æ”¯æŒ OpenGL 3.0+ (ç”¨äº 3D é¢„è§ˆ)

æ¨èé…ç½®ï¼š
- **CPU**: å¤šæ ¸å¤„ç†å™¨ (æ”¯æŒå¹¶è¡Œå¤„ç†)
- **å†…å­˜**: 16GB+ (å¤„ç†å¤§æ–‡ä»¶)
- **æ˜¾å¡**: ç‹¬ç«‹æ˜¾å¡ (æ›´å¥½çš„ 3D æ¸²æŸ“ä½“éªŒ)

### Q5: å¦‚ä½•é€‰æ‹©å®‰è£…å“ªäº›å¯é€‰ä¾èµ–ï¼Ÿ

**A:** æ ¹æ®æ‚¨çš„ä½¿ç”¨éœ€æ±‚é€‰æ‹©ï¼š

```bash
# åŸºç¡€å®‰è£… (ä»…æ ¸å¿ƒåŠŸèƒ½)
pip install assetx

# ç½‘æ ¼å¤„ç†åŠŸèƒ½
pip install assetx[mesh]  # æ·»åŠ  trimesh

# 3D å¯è§†åŒ–åŠŸèƒ½  
pip install assetx[viewer]  # æ·»åŠ  open3d

# URDF æ”¯æŒ
pip install assetx[urdf]  # æ·»åŠ  urdfpy

# å®Œæ•´å®‰è£… (æ‰€æœ‰åŠŸèƒ½)
pip install assetx[all]
```

**é€‰æ‹©å»ºè®®**:
- åˆå­¦è€…: `assetx[all]` (è·å¾—å®Œæ•´ä½“éªŒ)
- ç”Ÿäº§ç¯å¢ƒ: æŒ‰éœ€å®‰è£… (å‡å°éƒ¨ç½²åŒ…å¤§å°)
- CI/CD: `assetx` (åŸºç¡€ç‰ˆæœ¬ï¼Œå¿«é€Ÿå®‰è£…)

### Q6: å®‰è£…è¿‡ç¨‹ä¸­é‡åˆ°ç½‘ç»œé—®é¢˜æ€ä¹ˆåŠï¼Ÿ

**A:** ç½‘ç»œé—®é¢˜è§£å†³æ–¹æ¡ˆï¼š

1. **ä½¿ç”¨å›½å†…é•œåƒæº**
```bash
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple assetx
```

2. **ç¦»çº¿å®‰è£…**
```bash
# åœ¨æœ‰ç½‘ç»œçš„æœºå™¨ä¸Šä¸‹è½½
pip download assetx[all] -d ./packages

# åœ¨ç›®æ ‡æœºå™¨ä¸Šå®‰è£…
pip install --no-index --find-links ./packages assetx
```

3. **åˆ†æ­¥å®‰è£…**
```bash
# å…ˆå®‰è£…åŸºç¡€ä¾èµ–
pip install click pyyaml numpy

# å†å®‰è£… AssetX
pip install assetx --no-deps
```

---

## ä½¿ç”¨é—®é¢˜

### Q7: å¦‚ä½•å¼€å§‹ä½¿ç”¨ AssetXï¼Ÿ

**A:** æ¨èçš„å­¦ä¹ è·¯å¾„ï¼š

1. **åŸºç¡€è½¬æ¢** (15åˆ†é’Ÿ)
```bash
# ä¸‹è½½ç¤ºä¾‹æ–‡ä»¶æˆ–ä½¿ç”¨æ‚¨çš„ URDF
assetx convert --source robot.urdf --to mjcf --output robot.xml
```

2. **éªŒè¯ç»“æœ** (5åˆ†é’Ÿ)
```bash
# éªŒè¯è½¬æ¢è´¨é‡
assetx validate --ref robot.urdf --target robot.xml
```

3. **é¢„è§ˆæ¨¡å‹** (5åˆ†é’Ÿ)
```bash
# 3D é¢„è§ˆ
assetx preview --path robot.urdf
```

4. **å­¦ä¹  Python API** (30åˆ†é’Ÿ)
```python
from assetx import Asset, FormatConverter

asset = Asset("robot.urdf")
asset.load()

converter = FormatConverter()
converter.convert("robot.urdf", "mjcf", "robot.xml")
```

### Q8: è½¬æ¢åçš„æ–‡ä»¶ä¸åŸæ–‡ä»¶æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

**A:** è½¬æ¢è¿‡ç¨‹ä¸­çš„å˜åŒ–ï¼š

**ä¿æŒä¸å˜çš„éƒ¨åˆ†**:
- å…³èŠ‚å±‚æ¬¡ç»“æ„
- å…³èŠ‚ç±»å‹å’Œé™åˆ¶
- è´¨é‡å’Œæƒ¯æ€§å±æ€§
- å‡ ä½•å½¢çŠ¶å®šä¹‰

**å¯èƒ½å˜åŒ–çš„éƒ¨åˆ†**:
- æ–‡ä»¶æ ¼å¼è¯­æ³•
- åæ ‡ç³»çº¦å®š (æ ¹æ®ç›®æ ‡æ ¼å¼è°ƒæ•´)
- æè´¨å’Œçº¹ç†è¡¨ç¤º
- ä¼ æ„Ÿå™¨å’Œæ§åˆ¶å™¨å®šä¹‰

**å»ºè®®**:
- è½¬æ¢åå§‹ç»ˆè¿›è¡ŒéªŒè¯
- åœ¨ä»¿çœŸå™¨ä¸­æµ‹è¯•åŠŸèƒ½
- å¯¹æ¯”å…³é”®ç‰©ç†å‚æ•°

### Q9: å¦‚ä½•å¤„ç†ç½‘æ ¼æ–‡ä»¶è·¯å¾„é—®é¢˜ï¼Ÿ

**A:** å¸¸è§ç½‘æ ¼è·¯å¾„é—®é¢˜åŠè§£å†³æ–¹æ¡ˆï¼š

**é—®é¢˜ç±»å‹**:
1. ç»å¯¹è·¯å¾„ vs ç›¸å¯¹è·¯å¾„
2. ä¸åŒæ“ä½œç³»ç»Ÿçš„è·¯å¾„åˆ†éš”ç¬¦
3. ç½‘æ ¼æ–‡ä»¶ç§»åŠ¨æˆ–ç¼ºå¤±

**è§£å†³æ–¹æ¡ˆ**:
```python
from assetx import Asset
import xml.etree.ElementTree as ET
from pathlib import Path

def fix_mesh_paths(urdf_path: str, mesh_directory: str):
    """ä¿®å¤ URDF ä¸­çš„ç½‘æ ¼è·¯å¾„"""
    tree = ET.parse(urdf_path)
    root = tree.getroot()
    
    for mesh in root.findall(".//mesh"):
        old_path = mesh.get("filename")
        if old_path and not Path(old_path).exists():
            # å°è¯•åœ¨æŒ‡å®šç›®å½•æŸ¥æ‰¾
            mesh_name = Path(old_path).name
            new_path = Path(mesh_directory) / mesh_name
            
            if new_path.exists():
                # ä½¿ç”¨ç›¸å¯¹è·¯å¾„
                mesh.set("filename", f"{mesh_directory}/{mesh_name}")
                print(f"ä¿®å¤: {old_path} -> {new_path}")
    
    # ä¿å­˜ä¿®å¤åçš„æ–‡ä»¶
    fixed_path = urdf_path.replace('.urdf', '_fixed.urdf')
    tree.write(fixed_path)
    return fixed_path

# ä½¿ç”¨ç¤ºä¾‹
fixed_urdf = fix_mesh_paths("robot.urdf", "./meshes")
```

### Q10: å¦‚ä½•æ‰¹é‡å¤„ç†å¤šä¸ªæ–‡ä»¶ï¼Ÿ

**A:** æ‰¹é‡å¤„ç†çš„å‡ ç§æ–¹æ³•ï¼š

**æ–¹æ³•1: å‘½ä»¤è¡Œæ‰¹å¤„ç† (Bash)**
```bash
#!/bin/bash
for urdf_file in ./robots/*.urdf; do
    filename=$(basename "$urdf_file" .urdf)
    echo "å¤„ç†: $filename"
    assetx convert -s "$urdf_file" -t mjcf -o "./output/${filename}.xml"
done
```

**æ–¹æ³•2: Python è„šæœ¬**
```python
from pathlib import Path
from assetx import FormatConverter

def batch_convert(input_dir: str, output_dir: str, target_format: str):
    converter = FormatConverter()
    input_path = Path(input_dir)
    output_path = Path(output_dir)
    output_path.mkdir(exist_ok=True)
    
    # æŸ¥æ‰¾æ‰€æœ‰ URDF æ–‡ä»¶
    urdf_files = list(input_path.glob("*.urdf"))
    
    for urdf_file in urdf_files:
        output_file = output_path / f"{urdf_file.stem}.xml"
        
        print(f"è½¬æ¢: {urdf_file.name} -> {output_file.name}")
        
        try:
            success = converter.convert(
                str(urdf_file), 
                target_format, 
                str(output_file)
            )
            
            if success:
                print(f"âœ… æˆåŠŸ: {urdf_file.name}")
            else:
                print(f"âŒ å¤±è´¥: {urdf_file.name}")
                
        except Exception as e:
            print(f"âŒ é”™è¯¯: {urdf_file.name} - {e}")

# ä½¿ç”¨ç¤ºä¾‹
batch_convert("./input_robots", "./output_robots", "mjcf")
```

**æ–¹æ³•3: å¹¶è¡Œå¤„ç†**
```python
from concurrent.futures import ThreadPoolExecutor
from assetx import FormatConverter

def convert_single_file(args):
    source, target_format, output = args
    converter = FormatConverter()
    return converter.convert(source, target_format, output)

def parallel_batch_convert(file_list, max_workers=4):
    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        results = list(executor.map(convert_single_file, file_list))
    
    success_count = sum(results)
    print(f"æ‰¹é‡è½¬æ¢å®Œæˆ: {success_count}/{len(file_list)} æˆåŠŸ")

# å‡†å¤‡æ–‡ä»¶åˆ—è¡¨
files_to_convert = [
    ("robot1.urdf", "mjcf", "robot1.xml"),
    ("robot2.urdf", "mjcf", "robot2.xml"),
    # æ›´å¤šæ–‡ä»¶...
]

parallel_batch_convert(files_to_convert)
```

---

## é«˜çº§åŠŸèƒ½

### Q11: å¦‚ä½•è‡ªå®šä¹‰éªŒè¯è§„åˆ™ï¼Ÿ

**A:** æ‰©å±•éªŒè¯åŠŸèƒ½ï¼š

```python
from assetx import PhysicsValidator, Asset
from assetx.core.validator import ValidationResult

class CustomValidator(PhysicsValidator):
    def __init__(self):
        super().__init__()
        
    def validate_joint_naming(self, asset: Asset) -> list:
        """éªŒè¯å…³èŠ‚å‘½åè§„èŒƒ"""
        errors = []
        
        for joint in asset.joints:
            # æ£€æŸ¥å‘½åè§„èŒƒ: joint_[type]_[number]
            if not joint.name.startswith('joint_'):
                errors.append(f"å…³èŠ‚å‘½åä¸è§„èŒƒ: {joint.name}")
                
            # æ£€æŸ¥é‡å¤åç§°
            joint_names = [j.name for j in asset.joints]
            if joint_names.count(joint.name) > 1:
                errors.append(f"å…³èŠ‚åç§°é‡å¤: {joint.name}")
        
        return errors
    
    def validate_mass_distribution(self, asset: Asset) -> list:
        """éªŒè¯è´¨é‡åˆ†å¸ƒåˆç†æ€§"""
        errors = []
        
        masses = [link.mass for link in asset.links if hasattr(link, 'mass')]
        if not masses:
            return ["æœªæ‰¾åˆ°è´¨é‡ä¿¡æ¯"]
            
        total_mass = sum(masses)
        if total_mass < 0.1:
            errors.append(f"æ€»è´¨é‡è¿‡å°: {total_mass} kg")
        elif total_mass > 1000:
            errors.append(f"æ€»è´¨é‡è¿‡å¤§: {total_mass} kg")
            
        # æ£€æŸ¥è´¨é‡åˆ†å¸ƒå‡åŒ€æ€§
        max_mass = max(masses)
        min_mass = min(masses)
        if max_mass / min_mass > 100:
            errors.append(f"è´¨é‡åˆ†å¸ƒä¸å‡: æœ€å¤§/æœ€å° = {max_mass/min_mass:.1f}")
            
        return errors
    
    def validate_asset(self, asset: Asset) -> ValidationResult:
        """æ‰©å±•çš„éªŒè¯æ–¹æ³•"""
        # è°ƒç”¨åŸºç¡€éªŒè¯
        result = super().validate_asset(asset)
        
        # æ·»åŠ è‡ªå®šä¹‰éªŒè¯
        joint_errors = self.validate_joint_naming(asset)
        mass_errors = self.validate_mass_distribution(asset)
        
        result.errors.extend(joint_errors + mass_errors)
        
        if joint_errors or mass_errors:
            result.is_valid = False
            
        return result

# ä½¿ç”¨è‡ªå®šä¹‰éªŒè¯å™¨
validator = CustomValidator()
asset = Asset("robot.urdf")
asset.load()

result = validator.validate_asset(asset)
print(f"éªŒè¯ç»“æœ: {'é€šè¿‡' if result.is_valid else 'å¤±è´¥'}")
for error in result.errors:
    print(f"  âŒ {error}")
```

### Q12: å¦‚ä½•ä¼˜åŒ–å¤§æ–‡ä»¶çš„å¤„ç†æ€§èƒ½ï¼Ÿ

**A:** æ€§èƒ½ä¼˜åŒ–ç­–ç•¥ï¼š

**1. ç½‘æ ¼ä¼˜åŒ–**
```python
from assetx import MeshProcessor

processor = MeshProcessor()

# é¢„å¤„ç†ï¼šç®€åŒ–å¤æ‚ç½‘æ ¼
def optimize_meshes_for_simulation(asset_dir: str):
    mesh_files = Path(asset_dir).glob("**/*.obj")
    
    for mesh_file in mesh_files:
        # æ£€æŸ¥æ–‡ä»¶å¤§å°
        file_size_mb = mesh_file.stat().st_size / (1024 * 1024)
        
        if file_size_mb > 10:  # å¤§äº 10MB çš„æ–‡ä»¶
            print(f"ä¼˜åŒ–å¤§æ–‡ä»¶: {mesh_file.name} ({file_size_mb:.1f}MB)")
            
            # æ¿€è¿›ç®€åŒ–
            simplified = processor.simplify_mesh(
                str(mesh_file),
                target_faces=min(2000, int(file_size_mb * 100))
            )
            
            # æ›¿æ¢åŸæ–‡ä»¶
            mesh_file.replace(mesh_file.with_suffix('.obj.backup'))
            Path(simplified).replace(mesh_file)
```

**2. å†…å­˜ç®¡ç†**
```python
import gc
import psutil

class MemoryAwareProcessor:
    def __init__(self, memory_limit_mb=4000):
        self.memory_limit = memory_limit_mb
        
    def check_memory_usage(self):
        """æ£€æŸ¥å†…å­˜ä½¿ç”¨æƒ…å†µ"""
        process = psutil.Process()
        memory_mb = process.memory_info().rss / 1024 / 1024
        
        if memory_mb > self.memory_limit:
            print(f"å†…å­˜ä½¿ç”¨è¿‡é«˜: {memory_mb:.1f}MB, å¼ºåˆ¶å›æ”¶")
            gc.collect()
            
        return memory_mb
    
    def process_file_with_memory_control(self, file_path: str):
        """å¸¦å†…å­˜æ§åˆ¶çš„æ–‡ä»¶å¤„ç†"""
        self.check_memory_usage()
        
        # å¤„ç†æ–‡ä»¶
        asset = Asset(file_path)
        asset.load()
        
        # æ£€æŸ¥å†…å­˜
        memory_after = self.check_memory_usage()
        
        # å¤„ç†å®Œæˆåæ¸…ç†
        del asset
        gc.collect()
        
        return memory_after
```

**3. å¹¶è¡Œå¤„ç†**
```python
from multiprocessing import Pool
import os

def process_single_robot(args):
    """å•ä¸ªæœºå™¨äººå¤„ç†å‡½æ•°"""
    robot_path, output_dir = args
    
    try:
        # åœ¨å­è¿›ç¨‹ä¸­å¤„ç†
        from assetx import FormatConverter
        converter = FormatConverter()
        
        output_path = Path(output_dir) / f"{Path(robot_path).stem}.xml"
        success = converter.convert(robot_path, "mjcf", str(output_path))
        
        return robot_path, success, None
        
    except Exception as e:
        return robot_path, False, str(e)

def parallel_process_robots(robot_files: list, output_dir: str):
    """å¹¶è¡Œå¤„ç†å¤šä¸ªæœºå™¨äºº"""
    # ä½¿ç”¨ CPU æ ¸å¿ƒæ•°
    num_workers = min(len(robot_files), os.cpu_count())
    
    args_list = [(robot_file, output_dir) for robot_file in robot_files]
    
    with Pool(processes=num_workers) as pool:
        results = pool.map(process_single_robot, args_list)
    
    # ç»Ÿè®¡ç»“æœ
    success_count = sum(1 for _, success, _ in results if success)
    print(f"å¹¶è¡Œå¤„ç†å®Œæˆ: {success_count}/{len(robot_files)} æˆåŠŸ")
    
    # æŠ¥å‘Šé”™è¯¯
    for robot_path, success, error in results:
        if not success:
            print(f"âŒ {Path(robot_path).name}: {error}")
```

### Q13: å¦‚ä½•é›†æˆ AssetX åˆ° CI/CD æµç¨‹ï¼Ÿ

**A:** CI/CD é›†æˆç¤ºä¾‹ï¼š

**GitHub Actions é…ç½®** (`.github/workflows/assetx-validation.yml`)
```yaml
name: AssetX Asset Validation

on:
  push:
    paths:
      - 'robots/**/*.urdf'
      - 'robots/**/*.xml'
  pull_request:
    paths:
      - 'robots/**/*.urdf'
      - 'robots/**/*.xml'

jobs:
  validate-assets:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: Install AssetX
      run: |
        pip install assetx[all]
    
    - name: Validate URDF files
      run: |
        find robots/ -name "*.urdf" -exec assetx validate --path {} \;
    
    - name: Test conversions
      run: |
        mkdir -p converted_assets
        find robots/ -name "*.urdf" | while read urdf_file; do
          base_name=$(basename "$urdf_file" .urdf)
          assetx convert --source "$urdf_file" --to mjcf --output "converted_assets/${base_name}.xml"
        done
    
    - name: Upload conversion results
      uses: actions/upload-artifact@v3
      with:
        name: converted-assets
        path: converted_assets/
```

**Docker é›†æˆ**
```dockerfile
# Dockerfile
FROM python:3.9-slim

# å®‰è£…ç³»ç»Ÿä¾èµ–
RUN apt-get update && apt-get install -y \
    libgl1-mesa-glx \
    libglib2.0-0 \
    && rm -rf /var/lib/apt/lists/*

# å®‰è£… AssetX
RUN pip install assetx[all]

# è®¾ç½®å·¥ä½œç›®å½•
WORKDIR /workspace

# å¤åˆ¶éªŒè¯è„šæœ¬
COPY validate_assets.py /usr/local/bin/
RUN chmod +x /usr/local/bin/validate_assets.py

ENTRYPOINT ["python", "/usr/local/bin/validate_assets.py"]
```

**Jenkins Pipeline**
```groovy
pipeline {
    agent any
    
    stages {
        stage('Setup') {
            steps {
                sh 'python -m venv venv'
                sh 'source venv/bin/activate && pip install assetx[all]'
            }
        }
        
        stage('Validate Assets') {
            steps {
                sh '''
                    source venv/bin/activate
                    find . -name "*.urdf" | xargs -I {} assetx validate --path {}
                '''
            }
        }
        
        stage('Convert Assets') {
            steps {
                sh '''
                    source venv/bin/activate
                    mkdir -p converted
                    find . -name "*.urdf" | while read file; do
                        base=$(basename "$file" .urdf)
                        assetx convert --source "$file" --to mjcf --output "converted/${base}.xml"
                    done
                '''
            }
        }
    }
    
    post {
        always {
            archiveArtifacts artifacts: 'converted/**/*', fingerprint: true
        }
    }
}
```

---

## æ•…éšœæ’é™¤

### Q14: è½¬æ¢ç»“æœåœ¨ä»¿çœŸå™¨ä¸­è¡¨ç°å¼‚å¸¸æ€ä¹ˆåŠï¼Ÿ

**A:** ç³»ç»Ÿæ€§æ•…éšœæ’é™¤æµç¨‹ï¼š

**ç¬¬1æ­¥: éªŒè¯è½¬æ¢è´¨é‡**
```bash
# ä½¿ç”¨ AssetX éªŒè¯
assetx validate --ref original.urdf --target converted.xml

# æ£€æŸ¥ç‰©ç†å‚æ•°
assetx validate --path converted.xml --output validation_report.html --format html
```

**ç¬¬2æ­¥: æ£€æŸ¥å…³é”®å‚æ•°**
```python
from assetx import Asset

def compare_key_parameters(original_path: str, converted_path: str):
    """æ¯”è¾ƒå…³é”®å‚æ•°"""
    
    original = Asset(original_path)
    converted = Asset(converted_path)
    original.load()
    converted.load()
    
    print("=== åŸºæœ¬ä¿¡æ¯å¯¹æ¯” ===")
    print(f"åŸå§‹æ–‡ä»¶ - é“¾æ¥æ•°: {len(original.links)}, å…³èŠ‚æ•°: {len(original.joints)}")
    print(f"è½¬æ¢æ–‡ä»¶ - é“¾æ¥æ•°: {len(converted.links)}, å…³èŠ‚æ•°: {len(converted.joints)}")
    
    print("\n=== è´¨é‡å¯¹æ¯” ===")
    orig_total_mass = sum(getattr(link, 'mass', 0) for link in original.links)
    conv_total_mass = sum(getattr(link, 'mass', 0) for link in converted.links)
    print(f"åŸå§‹æ€»è´¨é‡: {orig_total_mass:.3f} kg")
    print(f"è½¬æ¢æ€»è´¨é‡: {conv_total_mass:.3f} kg")
    print(f"å·®å¼‚: {abs(orig_total_mass - conv_total_mass):.3f} kg")
    
    print("\n=== å…³èŠ‚é™åˆ¶å¯¹æ¯” ===")
    for orig_joint in original.joints:
        # æŸ¥æ‰¾å¯¹åº”å…³èŠ‚
        conv_joint = next(
            (j for j in converted.joints if j.name == orig_joint.name), 
            None
        )
        
        if conv_joint:
            print(f"å…³èŠ‚ {orig_joint.name}:")
            if hasattr(orig_joint, 'limits') and hasattr(conv_joint, 'limits'):
                print(f"  åŸå§‹é™åˆ¶: {orig_joint.limits}")
                print(f"  è½¬æ¢é™åˆ¶: {conv_joint.limits}")
        else:
            print(f"âš ï¸ å…³èŠ‚ {orig_joint.name} åœ¨è½¬æ¢æ–‡ä»¶ä¸­æœªæ‰¾åˆ°")

# ä½¿ç”¨ç¤ºä¾‹
compare_key_parameters("robot.urdf", "robot.xml")
```

**ç¬¬3æ­¥: ä»¿çœŸå™¨ç‰¹å®šæ£€æŸ¥**

å¯¹äº **MuJoCo**:
```bash
# ä½¿ç”¨ MuJoCo è‡ªå¸¦å·¥å…·éªŒè¯
simulate robot.xml

# æ£€æŸ¥ MuJoCo ç‰¹å®šè­¦å‘Š
python -c "
import mujoco
model = mujoco.MjModel.from_xml_path('robot.xml')
print('æ¨¡å‹åŠ è½½æˆåŠŸï¼ŒDOF:', model.nv)
"
```

å¯¹äº **Gazebo**:
```bash
# æ£€æŸ¥ URDF è¯­æ³•
check_urdf robot.urdf

# åœ¨ Gazebo ä¸­éªŒè¯
gazebo robot.urdf
```

### Q15: å¦‚ä½•å¤„ç†å¤§è§„æ¨¡èµ„äº§åº“çš„ç®¡ç†ï¼Ÿ

**A:** ä¼ä¸šçº§èµ„äº§ç®¡ç†æ–¹æ¡ˆï¼š

**1. ç›®å½•ç»“æ„è§„èŒƒ**
```
robot_assets/
â”œâ”€â”€ manufacturers/
â”‚   â”œâ”€â”€ universal_robots/
â”‚   â”‚   â”œâ”€â”€ ur5e/
â”‚   â”‚   â”‚   â”œâ”€â”€ urdf/
â”‚   â”‚   â”‚   â”œâ”€â”€ mjcf/
â”‚   â”‚   â”‚   â”œâ”€â”€ meshes/
â”‚   â”‚   â”‚   â””â”€â”€ metadata/
â”‚   â”‚   â””â”€â”€ ur10e/
â”‚   â””â”€â”€ franka_emika/
â”œâ”€â”€ categories/
â”‚   â”œâ”€â”€ manipulators/
â”‚   â”œâ”€â”€ mobile_robots/
â”‚   â””â”€â”€ humanoids/
â””â”€â”€ templates/
    â”œâ”€â”€ base_templates/
    â””â”€â”€ sensor_configs/
```

**2. èµ„äº§æ³¨å†Œç³»ç»Ÿ**
```python
import sqlite3
import json
from pathlib import Path
from datetime import datetime

class AssetRegistry:
    def __init__(self, db_path: str = "asset_registry.db"):
        self.db_path = db_path
        self._init_database()
    
    def _init_database(self):
        """åˆå§‹åŒ–æ•°æ®åº“"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS assets (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT UNIQUE NOT NULL,
                category TEXT NOT NULL,
                manufacturer TEXT,
                version TEXT,
                formats TEXT,  -- JSON string
                file_paths TEXT,  -- JSON string
                metadata_path TEXT,
                created_at TIMESTAMP,
                updated_at TIMESTAMP,
                validation_status TEXT,
                tags TEXT  -- JSON string
            )
        ''')
        
        conn.commit()
        conn.close()
    
    def register_asset(self, asset_info: dict):
        """æ³¨å†Œæ–°èµ„äº§"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        now = datetime.now().isoformat()
        
        cursor.execute('''
            INSERT OR REPLACE INTO assets 
            (name, category, manufacturer, version, formats, file_paths, 
             metadata_path, created_at, updated_at, validation_status, tags)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            asset_info['name'],
            asset_info['category'],
            asset_info.get('manufacturer', ''),
            asset_info.get('version', '1.0.0'),
            json.dumps(asset_info.get('formats', [])),
            json.dumps(asset_info.get('file_paths', {})),
            asset_info.get('metadata_path', ''),
            now, now,
            asset_info.get('validation_status', 'pending'),
            json.dumps(asset_info.get('tags', []))
        ))
        
        conn.commit()
        conn.close()
    
    def search_assets(self, **criteria):
        """æœç´¢èµ„äº§"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        where_clauses = []
        params = []
        
        for key, value in criteria.items():
            if key in ['name', 'category', 'manufacturer']:
                where_clauses.append(f"{key} LIKE ?")
                params.append(f"%{value}%")
        
        where_sql = " AND ".join(where_clauses) if where_clauses else "1=1"
        
        cursor.execute(f'''
            SELECT name, category, manufacturer, version, formats, file_paths
            FROM assets WHERE {where_sql}
        ''', params)
        
        results = cursor.fetchall()
        conn.close()
        
        return [
            {
                'name': row[0],
                'category': row[1], 
                'manufacturer': row[2],
                'version': row[3],
                'formats': json.loads(row[4]),
                'file_paths': json.loads(row[5])
            }
            for row in results
        ]

# ä½¿ç”¨ç¤ºä¾‹
registry = AssetRegistry()

# æ³¨å†Œèµ„äº§
registry.register_asset({
    'name': 'UR5e',
    'category': 'manipulator',
    'manufacturer': 'Universal Robots',
    'version': '1.0.0',
    'formats': ['urdf', 'mjcf'],
    'file_paths': {
        'urdf': './ur5e/ur5e.urdf',
        'mjcf': './ur5e/ur5e.xml'
    },
    'tags': ['collaborative', '6dof', 'industrial']
})

# æœç´¢èµ„äº§
results = registry.search_assets(category='manipulator', manufacturer='Universal')
for asset in results:
    print(f"æ‰¾åˆ°èµ„äº§: {asset['name']} - {asset['manufacturer']}")
```

**3. è‡ªåŠ¨åŒ–ç®¡é“**
```python
import schedule
import time
from pathlib import Path

class AssetMaintenancePipeline:
    def __init__(self, asset_root: str):
        self.asset_root = Path(asset_root)
        self.registry = AssetRegistry()
        
    def scan_and_register_new_assets(self):
        """æ‰«æå¹¶æ³¨å†Œæ–°èµ„äº§"""
        print("ğŸ” æ‰«ææ–°èµ„äº§...")
        
        urdf_files = self.asset_root.rglob("*.urdf")
        
        for urdf_file in urdf_files:
            # æ£€æŸ¥æ˜¯å¦å·²æ³¨å†Œ
            asset_name = urdf_file.stem
            existing = self.registry.search_assets(name=asset_name)
            
            if not existing:
                print(f"å‘ç°æ–°èµ„äº§: {asset_name}")
                self._process_new_asset(urdf_file)
    
    def _process_new_asset(self, urdf_path: Path):
        """å¤„ç†æ–°å‘ç°çš„èµ„äº§"""
        from assetx import Asset, FormatConverter, PhysicsValidator
        
        # åŠ è½½å’ŒéªŒè¯
        asset = Asset(str(urdf_path))
        asset.load()
        
        validator = PhysicsValidator()
        validation = validator.validate_asset(asset)
        
        # è‡ªåŠ¨è½¬æ¢åˆ°å…¶ä»–æ ¼å¼
        converter = FormatConverter()
        formats = ['urdf']
        file_paths = {'urdf': str(urdf_path)}
        
        # è½¬æ¢åˆ° MJCF
        mjcf_path = urdf_path.with_suffix('.xml')
        if converter.convert(str(urdf_path), 'mjcf', str(mjcf_path)):
            formats.append('mjcf')
            file_paths['mjcf'] = str(mjcf_path)
        
        # æ³¨å†Œåˆ°æ•°æ®åº“
        self.registry.register_asset({
            'name': urdf_path.stem,
            'category': self._detect_category(asset),
            'formats': formats,
            'file_paths': file_paths,
            'validation_status': 'valid' if validation.is_valid else 'invalid'
        })
    
    def _detect_category(self, asset):
        """è‡ªåŠ¨æ£€æµ‹èµ„äº§ç±»åˆ«"""
        joint_count = len(asset.joints)
        
        if joint_count == 0:
            return 'static_object'
        elif 'wheel' in str(asset.joints).lower():
            return 'mobile_robot'
        elif joint_count >= 6:
            return 'manipulator'
        else:
            return 'mechanism'
    
    def run_maintenance(self):
        """è¿è¡Œç»´æŠ¤ä»»åŠ¡"""
        print("ğŸ”§ å¼€å§‹èµ„äº§ç»´æŠ¤...")
        self.scan_and_register_new_assets()
        # å…¶ä»–ç»´æŠ¤ä»»åŠ¡...
        print("âœ… ç»´æŠ¤å®Œæˆ")

# è®¾ç½®å®šæ—¶ä»»åŠ¡
pipeline = AssetMaintenancePipeline("./robot_assets")

# æ¯å¤©å‡Œæ™¨2ç‚¹æ‰§è¡Œç»´æŠ¤
schedule.every().day.at("02:00").do(pipeline.run_maintenance)

# ä¿æŒè¿è¡Œ
while True:
    schedule.run_pending()
    time.sleep(3600)  # æ¯å°æ—¶æ£€æŸ¥ä¸€æ¬¡
```

---

## ç¤¾åŒºä¸æ”¯æŒ

### Q16: å¦‚ä½•æŠ¥å‘Š bug æˆ–è¯·æ±‚æ–°åŠŸèƒ½ï¼Ÿ

**A:** å‚ä¸ç¤¾åŒºçš„æ–¹å¼ï¼š

**æŠ¥å‘Š Bug**:
1. è®¿é—® [GitHub Issues](https://github.com/jandan138/AssetX/issues)
2. ä½¿ç”¨ Bug æŠ¥å‘Šæ¨¡æ¿
3. æä¾›ä»¥ä¸‹ä¿¡æ¯ï¼š
   - æ“ä½œç³»ç»Ÿå’Œ Python ç‰ˆæœ¬
   - AssetX ç‰ˆæœ¬
   - å®Œæ•´çš„é”™è¯¯ä¿¡æ¯
   - é‡ç°æ­¥éª¤å’Œæœ€å°ç¤ºä¾‹
   - ç›¸å…³æ–‡ä»¶ (å¦‚æœå¯èƒ½)

**åŠŸèƒ½è¯·æ±‚**:
1. å…ˆåœ¨ [Discussions](https://github.com/jandan138/AssetX/discussions) ä¸­è®¨è®º
2. æè¿°ä½¿ç”¨åœºæ™¯å’Œé¢„æœŸè¡Œä¸º
3. æä¾›ç›¸ä¼¼å·¥å…·çš„å‚è€ƒ
4. è€ƒè™‘å‘åå…¼å®¹æ€§

### Q17: å¦‚ä½•è´¡çŒ®ä»£ç ï¼Ÿ

**A:** è´¡çŒ®ä»£ç çš„æµç¨‹ï¼š

1. **Fork ä»“åº“**å¹¶åˆ›å»ºåŠŸèƒ½åˆ†æ”¯
2. **é˜…è¯»å¼€å‘æŒ‡å—** (`docs/development.md`)
3. **ç¼–å†™ä»£ç **å¹¶éµå¾ªä»£ç è§„èŒƒ
4. **æ·»åŠ æµ‹è¯•**ç¡®ä¿åŠŸèƒ½æ­£ç¡®
5. **æ›´æ–°æ–‡æ¡£**åæ˜ å˜æ›´
6. **æäº¤ Pull Request**

**è´¡çŒ®ç±»å‹**:
- ğŸ› Bug ä¿®å¤
- âœ¨ æ–°åŠŸèƒ½å¼€å‘
- ğŸ“š æ–‡æ¡£æ”¹è¿›
- ğŸ§ª æµ‹è¯•å¢å¼º
- ğŸ¨ ä»£ç ä¼˜åŒ–

### Q18: æœ‰å“ªäº›å­¦ä¹ èµ„æºï¼Ÿ

**A:** æ¨èçš„å­¦ä¹ èµ„æºï¼š

**å®˜æ–¹èµ„æº**:
- [å®Œæ•´æ–‡æ¡£](https://github.com/jandan138/AssetX/tree/main/docs)
- [API å‚è€ƒ](https://github.com/jandan138/AssetX/tree/main/docs/api)
- [ç¤ºä¾‹ä»£ç ](https://github.com/jandan138/AssetX/tree/main/examples)
- [æ•™ç¨‹è§†é¢‘](https://github.com/jandan138/AssetX/discussions)

**ç¤¾åŒºèµ„æº**:
- GitHub Discussions - æŠ€æœ¯è®¨è®º
- ç”¨æˆ·è´¡çŒ®çš„ç¤ºä¾‹å’Œå·¥å…·
- ç¬¬ä¸‰æ–¹æ•™ç¨‹å’Œåšå®¢æ–‡ç« 

**ç›¸å…³æŠ€æœ¯å­¦ä¹ **:
- **URDF**: [ROS URDF Tutorials](http://wiki.ros.org/urdf/Tutorials)
- **MuJoCo**: [MuJoCo Documentation](https://mujoco.readthedocs.io/)
- **USD**: [USD Documentation](https://graphics.pixar.com/usd/docs/index.html)
- **æœºå™¨äººå­¦**: ã€Šç°ä»£æœºå™¨äººå­¦ã€‹ç­‰ç»å…¸æ•™æ

---

å¦‚æœæ‚¨çš„é—®é¢˜æ²¡æœ‰åœ¨è¿™é‡Œæ‰¾åˆ°ç­”æ¡ˆï¼Œè¯·ä¸è¦çŠ¹è±«åœ¨ [GitHub Discussions](https://github.com/jandan138/AssetX/discussions) ä¸­æé—®ã€‚ç¤¾åŒºæˆå‘˜å¾ˆä¹æ„å¸®åŠ©æ‚¨ï¼
